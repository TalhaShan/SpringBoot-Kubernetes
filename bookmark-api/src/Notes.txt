1. starter test contains all mockiton junit
2. testcontainer postgresql added
3. @Container to use in test for using postegresql in test with ovveride database properites
@TestPropertySource(properties = {
        "spring.datasource.url=jdbc:tc:postgresql:14-alpine:///demo"
})

WITH THIS DOCKER IMAGE OF POSTGRESQL WE ARE RUNNING THE SAME ENV AS WE WILL HAVE ON PROD
4.     @ParameterizedTest
       @CsvSource({
               "1,15,2,1,true,false,true,false",
               "2,15,2,2,false,true,false,true"
       })

for parameterized test replace @Test

5. We can use docker or docker layer file to create image
6. More preferable is to Maven plugin to use that is auto configure in pom to generate docker file
7. mvn spring-boot:build-image -Dspring-boot.build-image.imageName=dock2727/bookmarker-api
Used to generate image with name or you can specify name in Pom.xml to by whcih name image should be create
8. mvn spring-boot:build-image //then this will only be needed
9. We can also use jib google plugin to generate image. it will also push it to docker hub
10. mvn -verify run build jar
11. Only pass pageable in query method will be sufficient spring will handle it page and size
12. We can have interface base projection and class based projection(DTO) //response or request
13. The void method will return 200 Ok but to modify we can use   @ResponseStatus(HttpStatus.CREATED) on method controller
14. tALK CONTAINER TO CONTAINER SPECIFY CONTAINER NAME INSTEAD OF HOST
//bookmarker-db:5432/appdb
15.  "15432:5432"  //HOST:CONTAINER
16. docker compose up -f file name  for any other file inseted od docker-compose.yml
17. docker-compose up -d --build  recreate the container
18. We can have separate docker file one for db one for application
docker-compose -f docker-compose.yml -f docker-compose-app.yml up -d
19. In next js there will be server side rendering and client side rendering two url one for client and one for internal host api calls
20. In docker we can run many containers as we want from single image refer docker1.png
21. Docker Volume: When we restart the container our data is lost so if our aplication is stateless like rest api
calls or something it get served
22. But what if we have some file manipulation and data need to be stored then we used docker it store our data
22. Or we can mapped data to local file system on our container
refer image: docker2.png
23. Where we can push or store our image refer docker3.png
24. To run multiple docker container we have docker compose we can simply define
depends on: like for db or something refer image docker4.png
25. all run on same container so they can discover each other.
26. Kubernetes is a container orchestration platform it maintains high availability and scalability
kubectl,kind,lens
27. Kubernetes
kubectl get pods  //to see available pods
You can create pods using commands or by usign yaml file 

kubectl run bookmarker-api --image=dock2727/bookmarker-api --port=8080
kubectl delete pod bookmarker-api
kubectl logs bookmarker-api -f
//to get into container
kubectl exec -it bookmarker-api -- /bin/sh
//then you can hit any endpoint to ccheck
